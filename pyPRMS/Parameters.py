
from __future__ import (absolute_import, division, print_function)
from future.utils import iteritems

import numpy as np
import sys


class Parameters(object):
    # Author: Parker Norton (pnorton@usgs.gov)
    # Create date: 2015-01-29
    # Description: Class object to handle reading and writing the PRMS
    #              parameter files which have been generated by Java.

    # TODO: Add basic statistical functions

    def __init__(self, filename):
        # 1) open file
        # 2) read file contents

        self.__isloaded = False
        self.__validparamsloaded = False  # Valid params are loaded by load_valid_parameters()
        self.__filename = filename
        self.__paramdict = {}
        self.__paramdb = None  # Dictionary of required parameters from *.par_name file(s)
        self.__header = []
        self.__vardict = {}
        self.__vardirty = True  # Flag to trigger rebuild of self.__vardict
        self.__catdelim = '**'  # Delimiter for categories of variables
        self.__rowdelim = '####'  # Used to delimit variables
        self.__valtypes = ['', 'integer', 'float', 'double', 'string']

        self.load_file()

    # END __init__

    def __getattr__(self, item):
        # Undefined attributes will look up the given parameter
        return self.get_var(item)

    @property
    def dimensions(self):
        """Return a list of dimensions"""
        if not self.__isloaded:
            self.load_file()

        # dimlist = []
        # parent = self.__paramdict['Dimensions']
        #
        # for kk,vv in parent.iteritems():
        #     dimlist.append((kk, vv))
        #
        # return dimlist
        return self.__paramdict['Dimensions']

    @property
    def filename(self):
        # if not self.__isloaded:
        #     self.load_file(self.__filename)
        return self.__filename

    @filename.setter
    def filename(self, fname):
        self.__isloaded = False

        self.__paramdict = {}
        self.__header = []

        self.__filename = fname

        self.load_file()

    @property
    def headers(self):
        """Returns the headers read from the parameter file"""
        return self.__header

    @property
    def vars(self):
        """Return a structure of loaded variables"""
        if not self.__isloaded:
            self.load_file()

        varlist = []
        parent = self.__paramdict['Parameters']

        for ee in parent:
            varlist.append(ee['name'])

        return varlist

    def add_dimension(self, dimname, value):
        """Add a new dimension"""
        if not self.__isloaded:
            self.load_file()

        parent = self.__paramdict['Dimensions']

        if dimname in parent:
            print('ERROR: Dimension already exists. %s = %d' % (dimname, parent[dimname]))
        else:
            parent[dimname] = int(value)

    def add_param(self, name, dimnames, valuetype, values):
        # Add a new parameter
        if not self.__isloaded:
            self.load_file()

        # Check that valuetype is valid
        if valuetype not in [1, 2, 3, 4]:
            print("ERROR: Invalid valuetype was specified")
            return

        # Check that total dimension size matches number of values supplied
        if isinstance(dimnames, list):
            # multiple dimensions supplied
            tsize = 1

            for dd in dimnames:
                tsize *= self.get_dim(dd)

            if tsize != len(values):
                print("ERROR: Number of values (%d) does not match size of dimensions (%d)" % (len(values), tsize))
                return
        else:
            # single dimension
            tsize = self.get_dim(dimnames)

            if isinstance(values, list):
                print("ERROR: Scalar dimensions specified but of list of values given")
                return

        parent = self.__paramdict['Parameters']

        # Make sure the parameter doesn't already exist
        if self.var_exists(name):
            print('ERROR: Parameter name already exists, use replace_values() instead.')
            return

        # for ee in parent:
        #     if ee['name'] == name:
        #         print 'ERROR: Parameter name already exists, use replace_values() instead.'
        #         return

        if isinstance(dimnames, list):
            parent.append({'name': name, 'dimnames': dimnames, 'valuetype': valuetype, 'values': values})
        else:
            parent.append({'name': name, 'dimnames': [dimnames], 'valuetype': valuetype, 'values': values})

        self.rebuild_vardict()

    def add_param_from_file(self, fname):
        """Add one or more parameter(s) from a file."""

        tmp_params = []

        infile = open(fname, 'r')
        rawdata = infile.read().splitlines()
        infile.close()

        it = iter(rawdata)

        for line in it:
            dupskip = False

            if line == self.__rowdelim:
                # Skip to next iteration when a row delimiter is found
                continue
            else:
                vardict = {}  # temporary to build variable info
                varname = line.split(' ')[0]

                # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # Check for duplicate variable name
                for kk in tmp_params:
                    # Check for duplicate variables (that couldn't happen! :))
                    # If it does skip to the next variable in the parameter file
                    if varname == kk['name']:
                        print('%s: Duplicate parameter name.. skipping' % varname)
                        dupskip = True
                        break

                if dupskip:
                    try:
                        while next(it) != self.__rowdelim:
                            pass
                    except StopIteration:
                        # We hit the end of the file
                        pass
                    continue
                # END check for duplicate varnames
                # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                vardict['name'] = varname

                # Read in the dimension names
                numdim = int(next(it))  # number of dimensions for this variable
                vardict['dimnames'] = [next(it) for dd in range(numdim)]

                # Lookup dimension size for each dimension name
                arr_shp = [self.__paramdict['Dimensions'][dd] for dd in vardict['dimnames']]

                numval = int(next(it))  # Denotes the number of data values we have. Should match dimensions.
                valuetype = int(next(it))  # Datatype of the values
                vardict['valuetype'] = int(valuetype)

                try:
                    # Read in the data values
                    vals = []

                    while True:
                        cval = next(it)

                        if cval == self.__rowdelim or cval.strip() == '':
                            break
                        vals.append(cval)
                except StopIteration:
                    # Hit the end of the file
                    pass

                if len(vals) != numval:
                    print('%s: number of values does not match dimension size (%d != %d).. skipping' %
                          (varname, len(vals), numval))
                else:
                    # Convert the values to the correct datatype
                    # 20151118 PAN: found a value of 1e+05 in nhm_id for r17 caused this to fail
                    #               even though manaully converting the value to int works.
                    try:
                        if valuetype == 1:  # integer
                            vals = [int(vals) for vals in vals]
                        elif valuetype == 2:  # float
                            vals = [float(vals) for vals in vals]
                    except ValueError:
                        print("%s: value type and defined type (%s) don't match" %
                              (varname, self.__valtypes[valuetype]))

                    # Add to dictionary as a numpy array
                    vardict['values'] = np.array(vals).reshape(arr_shp)
                    tmp_params.append(vardict)

        # Add or replace parameters depending on whether they already exist
        for pp in tmp_params:
            if self.var_exists(pp['name']):
                print("Replacing existing parameter: %s" % pp['name'])
                self.replace_values(pp['name'], pp['values'], pp['dimnames'])
            else:
                print("Adding new parameter: %s" % pp['name'])
                self.add_param(pp['name'], pp['dimnames'], pp['valuetype'], pp['values'])

    def check_var(self, varname):
        # Check a variable to see if the number of values it has is
        # consistent with the given dimensions

        if not self.__isloaded:
            self.load_file()

        thevar = self.get_var(varname)

        # Get the defined size for each dimension used by the variable
        total_size = 1
        for dd in thevar['dimnames']:
            total_size *= self.get_dim(dd)

        if thevar['values'].size == total_size:
            # The number of values for the defined dimensions match
            print('%s: OK' % varname)
        else:
            print('%s: BAD' % varname)

    def check_all_vars(self):
        """Check all parameter variables for proper array size"""
        if not self.__isloaded:
            self.load_file()

        parent = self.__paramdict['Parameters']

        for ee in parent:
            self.check_var(ee['name'])

    def check_all_module_vars(self, mods):
        """Given a .par_name file verify whether all needed parameters are in the parameter file"""
        # mods      Dictionary created by param_db.module_params()

        for (cmodule, params) in iteritems(mods):
            print('Module:', cmodule)

            for cparam in params:
                if cparam in ['gw_seep_coef', 'elevlake_init', 'lake_hru_id',
                              'lake_seep_elev', 'lake_hru', 'lake_type'] and not self.get_dim('nlake'):
                    continue
                elif cparam in ['basin_solsta', 'hru_solsta', 'rad_conv'] and not self.get_dim('nlake'):
                    continue
                elif cparam in ['irr_type'] and not self.get_dim('nwateruser'):
                    continue

                if not self.var_exists(cparam):
                    print('\t%s: MISSING' % cparam)

    def copy_param(self, varname, filename):
        """Copies selected varname from given src input parameter file (filename).
        The incoming parameter is verified to have the same dimensions and sizes as
        the destination. This method is intended to work with full parameter files.
        To copy parameters from partial parameter files use add_param_from_file()."""

        # TODO: Expand this handle one or more varnames
        srcparamfile = Parameters(filename)
        srcparam = srcparamfile.get_var(varname)

        if self.var_exists(srcparam['name']):
            print('Replacing existing parameter')
            self.replace_values(srcparam['name'], srcparam['values'], srcparam['dimnames'])
        else:
            print('Adding new parameter')
            self.add_param(srcparam['name'], srcparam['dimnames'], srcparam['valuetype'], srcparam['values'])
        del srcparamfile

    def distribute_mean_value(self, varname, new_mean):
        # def redistribute_mean(old_vals, new_mean):
        # Redistribute mean value to set of multiple initial values
        # see Hay and Umemoto, 2006 (p. 11)

        old_vals = self.get_var(varname)['values']

        if old_vals.size > 1:
            # This parameter is a list of values
            zc = 10.  # Constant to avoid zero values
            new_vals = []

            old_mean = old_vals.sum() / float(old_vals.size)

            for vv in old_vals.flatten():
                new_vals.append((((new_mean + zc) * (vv + zc)) / (old_mean + zc)) - zc)

            self.replace_values(varname, np.array(new_vals).reshape(old_vals.shape))
        else:
            # Even scalar values are stored as numpy arrays
            self.replace_values(varname, np.array(new_mean).reshape(old_vals.shape))

    def expand_params(self, valid_params):
        """Given a dictionary of valid parameters from paramdb will expand the
           input parameters to their maximum dimensionality"""
        # 1) Check that all parameters required by modules are present and expand them (add as necessary)
        #    1a) Handle parameters that need conversion and/or renaming (e.g. soil_rechr_max->soil_rechr_max_frac)
        #    1b) Missing parameters should be added with default values
        #    1c) Existing parameters should be expanded in place
        # 2) Remove any remaining deprecated or non-needed parameters
        # 3) Check parameter integrity

        param_type = {'long': 1, 'float': 2, 'double': 3, 'string': 4}

        # Deprecated parameter relationships
        # depr_params = {'smidx_coef': 'carea_min',
        depr_params = {'dprst_area': 'dprst_frac',
                       # 'hru_percent_imperv': 'imperv_frac',
                       'soil_moist_init': 'soil_moist_init_frac',
                       'soil_rechr_init': 'soil_rechr_init_frac',
                       'soil_rechr_max': 'soil_rechr_max_frac',
                       'sro_to_dprst': 'sro_to_dprst_perv',
                       'ssstor_init': 'ssstor_init_frac',
                       'tmax_allrain': 'tmax_allrain_offset'}

        if not self.__isloaded:
            self.load_file()

        # Iterator through parameters
        cparams = set(self.vars)
        vparams = set(valid_params.keys())

        # Parameters common to the deprecated params (depr_params) and the current input parameters (cparams)
        conv_params = set(depr_params.keys()).intersection(cparams)

        # =====================================================================
        # Deprecated parameters conversion
        # Convert (as necessary) and rename deprecated parameters to new names
        # This only converts existing data, expansion is done later
        remove_list = []
        for cc in conv_params:
            if cc == 'soil_rechr_max':
                # Convert with soil_rechr_max_frac = soil_rechr_max / soil_moist_max
                newparam = valid_params[depr_params[cc]]
                newarr = self.get_var(cc)['values'] / self.get_var('soil_moist_max')['values']
                self.add_param(depr_params[cc], self.get_var(cc)['dimnames'], param_type[newparam['Type']], newarr)
                remove_list.append(cc)
            elif cc == 'dprst_area':
                # Convert with dprst_frac = dprst_area / hru_area
                newparam = valid_params[depr_params[cc]]
                newarr = self.get_var(cc)['values'] / self.get_var('hru_area')['values']
                self.add_param(depr_params[cc], self.get_var(cc)['dimnames'], param_type[newparam['Type']], newarr)
                remove_list.append(cc)
            elif cc == 'tmax_allrain':
                # Convert with tmax_allrain_offset = tmax_allrain - tmax_allsnow
                newparam = valid_params[depr_params[cc]]
                newarr = self.get_var(cc)['values'] - self.get_var('tmax_allsnow')['values']
                self.add_param(depr_params[cc], self.get_var(cc)['dimnames'], param_type[newparam['Type']], newarr)
                remove_list.append(cc)
            elif cc == 'soil_moist_init':
                # Convert with soil_moist_init_frac = soil_moist_init / soil_moist_max
                newparam = valid_params[depr_params[cc]]
                newarr = self.get_var(cc)['values'] / self.get_var('soil_moist_max')['values']
                newarr[newarr > 1.0] = 1.0
                self.add_param(depr_params[cc], self.get_var(cc)['dimnames'], param_type[newparam['Type']], newarr)
                remove_list.append(cc)
            elif cc == 'soil_rechr_init':
                # Convert with soil_rechr_init_frac = soil_rechr_init / soil_rechr_max
                if self.var_exists('soil_rechr_init'):
                    if self.var_exists('soil_rechr_max'):
                        newparam = valid_params[depr_params[cc]]
                        newarr = self.get_var(cc)['values'] / self.get_var('soil_rechr_max')['values']
                        newarr[newarr > 1.0] = 1.0
                        self.add_param(depr_params[cc], self.get_var(cc)['dimnames'], param_type[newparam['Type']], newarr)
                    elif self.var_exists('soil_rechr_max_frac'):
                        # Compute with alternative equation of
                        # soil_rechr_init_frac = soil_rechr_init / (soil_rechr_max_frac * soil_moist_max)
                        newparam = valid_params[depr_params[cc]]
                        newarr = self.get_var(cc)['values'] / (self.get_var('soil_rechr_max_frac')['values'] * self.get_var('soil_moist_max')['values'])
                        newarr[newarr > 1.0] = 1.0
                        self.add_param(depr_params[cc], self.get_var(cc)['dimnames'], param_type[newparam['Type']], newarr)
                else:
                    print('ERROR: Missing parameters required for converting to %s' % valid_params[depr_params[cc]])
                remove_list.append(cc)
            elif cc == 'ssstor_init':
                # Convert with ssstor_init_frac = sstor_init / sat_threshold
                newparam = valid_params[depr_params[cc]]
                newarr = self.get_var(cc)['values'] / self.get_var('sat_threshold')['values']
                newarr[newarr > 1.0] = 1.0
                self.add_param(depr_params[cc], self.get_var(cc)['dimnames'], param_type[newparam['Type']], newarr)
                remove_list.append(cc)
            else:
                # Rename any other deprecated params
                # TODO: Many of the new _frac parameters need to be handled individually
                self.rename_param(cc, depr_params[cc])

        # Remove parameters that are deprecated
        for pp in remove_list:
            print("Removing deprecated parameter %s" % pp)
            self.remove_param(pp)
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        # =====================================================================
        # Add missing parameters using default values
        # Check for any valid params (vparams) that are missing from cparams.
        # These will be created with default values
        cparams = set(self.vars)
        def_params = vparams.difference(cparams)
        # print 'New parameters to create with default value:', def_params

        for pp in def_params:
            if pp in ['basin_solsta', 'hru_solsta', 'rad_conv'] and not self.get_dim('nsol'):
                # Shouldn't be added if nsol == 0
                continue
            elif pp in ['hru_pansta'] and not self.get_dim('nevapl'):
                # Shouldn't be added if nevapl == 0
                continue
            elif pp in ['lake_hru_id'] and not self.get_dim('nlake'):
                # Shouldn't be added if nlake == 0
                continue
            elif pp in ['irr_type'] and not self.get_dim('nwateruse'):
                # Shouldn't be added if nwateruser == 0
                continue
            elif pp in ['gvr_hru_id'] and not self.get_dim('nhrucell'):
                continue

            newparam = valid_params[pp]
            newarr = np.asarray(newparam['Default'])

            # Compute new dimension size
            newsize = 1
            for dd in newparam['Dimensions']:
                if self.get_dim(dd) is None:
                    print("Not adding %s because %s doesn't exist" % (pp, dd))
                    newsize = 0
                    break
                else:
                    newsize *= self.get_dim(dd)

            if newsize > 0:
                # Create new array, repeating default value to fill it
                newarr = np.resize(newarr, newsize)
                self.add_param(pp, newparam['Dimensions'], param_type[newparam['Type']], newarr)
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        # =====================================================================
        # Create set of cparams that are not needed by modules
        # Not used for now but it could be used to strip out unneeded additional parameters
        addl_params = cparams.difference(vparams)
        print('cparams not in validparams:', addl_params)
        print('-' * 40)

        # =====================================================================
        # Expand parameters whose dimensionality has changed
        for ee in vparams:
            if ee in ['basin_solsta', 'hru_solsta', 'rad_conv'] and not self.get_dim('nsol'):
                # Shouldn't be added if nsol == 0
                continue
            elif ee in ['hru_pansta'] and not self.get_dim('nevapl'):
                # Shouldn't be added if nevapl == 0
                continue
            elif ee in ['lake_hru_id'] and not self.get_dim('nlake'):
                # Shouldn't be added if nlake == 0
                continue
            elif ee in ['irr_type'] and not self.get_dim('nwateruse'):
                # Shouldn't be added if nwateruser == 0
                continue
            elif ee in ['gvr_hru_id'] and not self.get_dim('nhrucell'):
                continue

            cvar = self.get_var(ee)
            if cvar is None:
                print("Not expanding %s because parameter doesn't exist" % ee)
            else:
                cname = cvar['name']

                # Check for changed dimensionality
                cdimnames = cvar['dimnames']
                vdimnames = valid_params[cname]['Dimensions']

                if set(vdimnames).issubset(set(cdimnames)):
                    # NOTE: This doesn't properly handle the case when number of
                    #       dimensions has shrunk.
                    # print "%s: No dimensionality change" % cname
                    pass
                else:
                    # Parameter has a change in dimensionality
                    print("%s: Dimensionality changed from" % cname, cdimnames, 'to', vdimnames)

                    # Compute new dimension size
                    newsize = 1
                    for dd in vdimnames:
                        newsize *= self.get_dim(dd)

                    # Create new array, repeating original values to fill it
                    newarr = np.resize(cvar['values'], newsize)

                    self.replace_values(cname, newarr, vdimnames)
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        self.rebuild_vardict()
        return None

    def get_dim(self, dimname):
        # Return the size of the specified dimension

        if not self.__isloaded:
            self.load_file()

        parent = self.__paramdict['Dimensions']

        if dimname in parent:
            return parent[dimname]
        return None

    def get_var(self, varname):
        # Return the given variable

        if not self.__isloaded:
            self.load_file()

        parent = self.__paramdict['Parameters']

        for ee in parent:
            if ee['name'] == varname:
                return ee
        raise ValueError('Parameter does not exist.')

        return None

    def load_file(self):
        # Read the parameter file into memory and parse it

        self.__paramdict = {}  # Initialize the parameter dictionary
        self.__vardict = {}  # dictionary of parameter names to paramdict array index

        self.__header = []  # Initialize the list of file headers

        infile = open(self.__filename, 'r')
        rawdata = infile.read().splitlines()
        infile.close()

        it = iter(rawdata)
        curr_cat = None  # Current category (None, Dimensions, or Parameters)

        for line in it:
            dupskip = False

            if line[0:2] == self.__catdelim:
                # Found the category delimiter
                curr_cat = line.strip('* ')

                if curr_cat == 'Dimensions':
                    self.__paramdict[curr_cat] = {}
                elif curr_cat == 'Parameters':
                    self.__paramdict[curr_cat] = []
            elif line == self.__rowdelim:
                # Skip to next iteration when a row delimiter is found
                continue
            else:
                if curr_cat is None:
                    # Any lines up to the Dimensions category go into the header
                    # The parameter file header is defined to be exactly 2 lines
                    # but this will handle any number of header lines.
                    self.__header.append(line)
                elif curr_cat == 'Dimensions':
                    # Dimension variables are scalar integers
                    self.__paramdict[curr_cat][line] = int(next(it))
                elif curr_cat == 'Parameters':
                    vardict = {}  # temporary to build variable info
                    varname = line.split(' ')[0]

                    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    # Check for duplicate variable name
                    for kk in self.__paramdict['Parameters']:
                        # Check for duplicate variables (that couldn't happen! :))
                        # If it does skip to the next variable in the parameter file
                        if varname == kk['name']:
                            print('%s: Duplicate parameter name.. skipping' % varname)
                            dupskip = True
                            break

                    if dupskip:
                        try:
                            while next(it) != self.__rowdelim:
                                pass
                        except StopIteration:
                            # We hit the end of the file
                            pass
                        continue
                    # END check for duplicate varnames
                    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                    vardict['name'] = varname

                    # Read in the dimension names
                    numdim = int(next(it))  # number of dimensions for this variable
                    vardict['dimnames'] = [next(it) for dd in range(numdim)]

                    # Lookup dimension size for each dimension name
                    arr_shp = [self.__paramdict['Dimensions'][dd] for dd in vardict['dimnames']]
                    dim_size = reduce(lambda x, y: x*y, arr_shp)

                    numval = int(next(it))  # Denotes the number of data values we have. Should match dimensions.
                    valuetype = int(next(it))  # Datatype of the values
                    vardict['valuetype'] = int(valuetype)

                    if numval != dim_size:
                        # The declared total size doesn't match the total size of the declared dimensions
                        print('%s: Declared total size for parameter does not match the total size of the declared dimension(s) (%d != %d).. skipping'
                              % (varname, numval, dim_size))

                        # Still have to read all the values to skip this properly
                        try:
                            while True:
                                cval = next(it)

                                if cval == self.__rowdelim or cval.strip() == '':
                                    break
                        except StopIteration:
                            # Hit the end of the file
                            pass
                    else:
                        # Check if number of values written match the number of values declared
                        try:
                            # Read in the data values
                            vals = []

                            while True:
                                cval = next(it)

                                if cval == self.__rowdelim or cval.strip() == '':
                                    break
                                vals.append(cval)
                        except StopIteration:
                            # Hit the end of the file
                            pass

                        if len(vals) != numval:
                            print('%s: number of values does not match dimension size (%d != %d).. skipping' %
                                  (varname, len(vals), numval))
                        else:
                            # Convert the values to the correct datatype
                            # 20151118 PAN: found a value of 1e+05 in nhm_id for r17 caused this to fail
                            #               even though manaully converting the value to int works.
                            try:
                                if valuetype == 1:  # integer
                                    vals = [int(vals) for vals in vals]
                                elif valuetype == 2:  # float
                                    vals = [float(vals) for vals in vals]
                            except ValueError:
                                print("%s: value type and defined type (%s) don't match" %
                                      (varname, self.__valtypes[valuetype]))

                            # Add to dictionary as a numpy array
                            # Use column-major ordering for Fortran
                            vardict['values'] = np.array(vals).reshape(arr_shp, order='F')
                            self.__paramdict['Parameters'].append(vardict)

        # Build the vardict dictionary (links varname to array index in self.__paramdict)
        self.rebuild_vardict()

        self.__isloaded = True

    def pull_hru2(self, hru_index, filename):
        # Pulls a single HRU out by index and writes a new parameter file for that HRU
        # This version greatly improves on the original pull_hru by just reading from the parameter
        # data structure and writing the modified file directly instead of modifying a copy of the
        # original parameter structure and then writing it out.

        split_dims = ['nhru', 'nssr', 'ngw']
        ndepl = self.get_dim('ndepl')
        nhru = self.get_dim('nhru')
        order = ['name', 'dimnames', 'valuetype', 'values']

        # Parameters that need parent information saved
        # parent_info = {'hru_segment': 'parent_hru',
        #                'tosegment': 'parent_segment' }

        # List of vars that have dimension of nsegment
        # TODO: This should be auto-created from the parameter file based on the dimension type
        segvars = ['K_coef', 'obsin_segment', 'x_coef', 'segment_type', 'segment_flow_init', 'parent_segment',
                   'nhm_seg', 'tosegment_nhm']

        # Adjustment values for select dimensions
        dim_adj = {'nobs': 1, 'nsegment': 1, 'npoigages': 0}

        # ===================================================================
        outfile = open(filename, 'w')

        # -------------------------------------------------------------------
        for hh in self.__header:
            # Write out any header stuff
            outfile.write('%s\n' % hh)

        # Dimension section must be written first
        dimparent = self.__paramdict['Dimensions']

        outfile.write('%s Dimensions %s\n' % (self.__catdelim, self.__catdelim))

        # -------------------------------------------------------------------
        for (kk, vv) in iteritems(dimparent):
            # Write the dimension names and values separated by self.__rowdelim
            outfile.write('%s\n' % self.__rowdelim)
            outfile.write('%s\n' % kk)

            # Adjust the split_dims e.g. nhru, ngw, nssr and asssorted other dimensions
            if kk in split_dims:
                outfile.write('%d\n' % 1)
            elif kk in dim_adj:
                outfile.write('%d\n' % dim_adj[kk])
            elif kk == 'ndepl':
                outfile.write('%d\n' % 1)
            elif kk == 'ndeplval':
                outfile.write('%d\n' % 11)
            else:
                outfile.write('%d\n' % vv)

        # Now write out the Parameter category
        paramparent = self.__paramdict['Parameters']

        outfile.write('%s Parameters %s\n' % (self.__catdelim, self.__catdelim))

        # Get the segment index for the HRU we are grabbing
        seg_idx = self.get_var('hru_segment')['values'][hru_index]
        sys.stdout.write('\rHRU %06d to segment: %06d' % (hru_index, seg_idx))
        sys.stdout.flush()

        # -------------------------------------------------------------------
        for vv in paramparent:
            valtype = vv['valuetype']

            # Set a format string based on the valtype
            if valtype == 1:
                fmt = '%s\n'
            elif valtype == 2:
                # fmt = '%0.8f\n'
                fmt = '%s\n'
            else:
                fmt = '%s\n'

            if bool(set(vv['dimnames']).intersection(split_dims)):
                # dealing with nhru, nssr, or ngw

                if len(vv['dimnames']) == 2:
                    the_values = vv['values'][hru_index, :]
                    dimsize = vv['values'][hru_index, :].size
                elif len(vv['dimnames']) == 1:
                    the_values = vv['values'][hru_index]
                    dimsize = vv['values'][hru_index].size
            elif bool(set(vv['dimnames']).intersection(set(['ndeplval']))):
                # The ndeplval dimension is actually nhru x 11
                # The index for ndeplval for each HRU is stored in hru_deplcrv
                crv_idx = self.get_var('hru_deplcrv')['values'][hru_index] - 1
                the_values = vv['values'].reshape((-1, 11), order='A')[crv_idx]
                dimsize = 11
            else:
                dimsize = vv['values'].size
                the_values = vv['values']

            # Special overrides for some parameters
            if vv['name'] in segvars:
                the_values = np.array([vv['values'][seg_idx - 1]])
                dimsize = 1
            elif vv['name'] == 'hru_deplcrv':
                # The hru_deplcrv parameter is the snarea_curve index for each HRU.
                # For a single HRU this should be reset to 1.
                the_values = np.array([1])
                dimsize = 1
            elif vv['name'] == 'hru_segment':
                the_values = np.array([1])
                dimsize = 1
            elif vv['name'] in ['tosegment']:
                the_values = np.array([0])
                dimsize = 1
            elif vv['name'] in ['poi_gage_segment', 'poi_type', 'poi_gage_id']:
                # 2016-03-24: Having these parameters causes PRMS to error out
                continue

            for item in order:
                # Write each variable write out separated by self.__rowdelim
                val = vv[item]

                if item == 'dimnames':
                    # Write number of dimensions first
                    outfile.write('%d\n' % len(val))
                    for dd in val:
                        # Write dimension names
                        outfile.write('%s\n' % dd)
                elif item == 'valuetype':
                    # dimsize (which is computed) must be written before valuetype
                    outfile.write('%d\n' % dimsize)
                    outfile.write('%d\n' % val)
                elif item == 'values':
                    # Write one value per line
                    for xx in the_values.flatten():
                        outfile.write(fmt % xx)
                elif item == 'name':
                    # Write the self.__rowdelim before the variable name
                    outfile.write('%s\n' % self.__rowdelim)
                    outfile.write('%s\n' % val)

        # Not quite done... add parent information so we can stitch the HRUs back together later
        # order = ['name', 'dimnames', 'valuetype', 'values']

        # Write the parent_segment information
        # The parent_segment is the value that was used in the parent parameter file for hru_segment at
        # the given parent_hru index. It shouldn't be needed for checking a single HRU back into the
        # parent parameter file.
        outfile.write('%s\n' % self.__rowdelim)
        outfile.write('%s\n' % 'parent_segment')
        outfile.write('%d\n' % 1)
        outfile.write('%s\n' % 'nsegment')
        outfile.write('%d\n' % 1)
        outfile.write('%d\n' % 1)
        outfile.write('%d\n' % seg_idx)

        # Write the parent_hru information
        # The parent_hru is the index to use when checking a single HRU file back into the parent parameter file
        outfile.write('%s\n' % self.__rowdelim)
        outfile.write('%s\n' % 'parent_hru')
        outfile.write('%d\n' % 1)
        outfile.write('%s\n' % 'nhru')
        outfile.write('%d\n' % 1)
        outfile.write('%d\n' % 1)
        outfile.write('%d\n' % (hru_index + 1))

        outfile.close()

    def rebuild_vardict(self):
        # Build the vardict dictionary (links varname to array index in self.__paramdict)
        self.__vardict = {}
        for idx, vname in enumerate(self.__paramdict['Parameters']):
            self.__vardict[vname['name']] = idx
        self.__vardirty = False

    def remove_param(self, varname):
        """Removes a parameter"""
        if not self.__isloaded:
            self.load_file()

        if self.get_var(varname) is not None:
            for ii, vv in enumerate(self.__paramdict['Parameters']):
                if vv['name'] == varname:
                    rmidx = ii

            del self.__paramdict['Parameters'][rmidx]

    def rename_param(self, varname, newname):
        """Renames a parameter"""
        if not self.__isloaded:
            self.load_file()

        thevar = self.get_var(varname)
        thevar['name'] = newname

    def replace_values(self, varname, newvals, newdims=None):
        """Replaces all values for a given variable/parameter. Size of old and new arrays/values must match."""
        if not self.__isloaded:
            self.load_file()

        # parent = self.__paramdict['Parameters']
        thevar = self.get_var(varname)

        # NOTE: Need to figure out whether this function should expect row-major ordering
        #       or column-major ordering when called. Right it expects column-major ordering
        #       for newvals, which means no re-ordering of the array is necessary when
        #       replacing values.
        if newdims is None:
            # We are not changing dimensions of the variable/parameter, just the values
            # Check if size of newvals array matches the oldvals array
            if isinstance(newvals, list) and len(newvals) == thevar['values'].size:
                # Size of arrays match so replace the oldvals with the newvals
                # Lookup dimension size for each dimension name
                arr_shp = [self.__paramdict['Dimensions'][dd] for dd in thevar['dimnames']]

                thevar['values'][:] = np.array(newvals).reshape(arr_shp)
            elif isinstance(newvals, np.ndarray) and newvals.size == thevar['values'].size:
                # newvals is a numpy ndarray
                # Size of arrays match so replace the oldvals with the newvals
                # Lookup dimension size for each dimension name
                arr_shp = [self.__paramdict['Dimensions'][dd] for dd in thevar['dimnames']]

                thevar['values'][:] = newvals.reshape(arr_shp)
            # NOTE: removed the following because even scalars should be stored as numpy array
            # elif thevar['values'].size == 1:
            #     # This is a scalar value
            #     if isinstance(newvals, float):
            #         thevar['values'] = [newvals]
            #     elif isinstance(newvals, int):
            #         thevar['values'] = [newvals]
            else:
                print("ERROR: Size of oldval array and size of newval array don't match")
        else:
            # The dimensions are being changed and new values provided

            # Use the dimension sizes from the parameter file to check the size
            # of the newvals array. If the size of the newvals array doesn't match the
            # parameter file's dimensions sizes we have a problem.
            size_check = 1
            for dd in newdims:
                size_check *= self.get_dim(dd)

            if isinstance(newvals, list) and len(newvals) == size_check:
                # Size of arrays match so replace the oldvals with the newvals
                thevar['values'] = newvals
                thevar['dimnames'] = newdims
            elif isinstance(newvals, np.ndarray) and newvals.size == size_check:
                # newvals is a numpy ndarray
                # Size of arrays match so replace the oldvals with the newvals
                thevar['values'] = newvals
                thevar['dimnames'] = newdims
            elif thevar['values'].size == 1:
                # This is a scalar value
                thevar['dimnames'] = newdims
                if isinstance(newvals, float):
                    thevar['values'] = [newvals]
                elif isinstance(newvals, int):
                    thevar['values'] = [newvals]
            else:
                print("ERROR: Size of newval array doesn't match dimensions in parameter file")

    def resize_dim(self, dimname, newsize):
        """Changes the size of the given dimension.
           This does *not* check validity of parameters that use the dimension.
           Check variable integrity before writing parameter file."""

        # Some dimensions are related to each other.
        related_dims = {'ndepl': 'ndeplval', 'nhru': ['nssr', 'ngw'],
                        'nssr': ['nhru', 'ngw'], 'ngw': ['nhru', 'nssr']}

        if not self.__isloaded:
            self.load_file()

        parent = self.__paramdict['Dimensions']

        if dimname in parent:
            parent[dimname] = newsize

            # Also update related dimensions
            if dimname in related_dims:
                if dimname == 'ndepl':
                    parent[related_dims[dimname]] = parent[dimname] * 11
                elif dimname in ['nhru', 'nssr', 'ngw']:
                    for dd in related_dims[dimname]:
                        parent[dd] = parent[dimname]
            return True
        else:
            return False

    def update_values_by_hru(self, varname, newvals, hru_index):
        """Updates parameter/variable with new values for a a given HRU.
           This is used when merging data from an individual HRU into a region"""
        if not self.__isloaded:
            self.load_file()

        # parent = self.__paramdict['Parameters']
        thevar = self.get_var(varname)

        if len(newvals) == 1:
            thevar['values'][(hru_index - 1)] = newvals
        elif len(newvals) == 2:
            thevar['values'][(hru_index - 1), :] = newvals
        elif len(newvals) == 3:
            thevar['values'][(hru_index - 1), :, :] = newvals

    def var_exists(self, varname):
        """Checks to see if a variable exists in the currently loaded parameter file.
           Returns true if the variable exists, otherwise false."""
        if not self.__isloaded:
            self.load_file()

        if varname in self.__vardict:
            return True
        return False

    def write_select_param_file(self, filename, selection):
        # Write selected subset of parameters to a new parameter file
        if not self.__isloaded:
            self.load_file()

        outfile = open(filename, 'w')

        # Write out the Parameter category
        order = ['name', 'dimnames', 'valuetype', 'values']

        for ss in selection:
            vv = self.get_var(ss)
            dimsize = vv['values'].size
            valtype = vv['valuetype']

            # Set a format string based on the valtype
            if valtype == 1:
                fmt = '%s\n'
            elif valtype == 2:
                # fmt = '%f\n'
                fmt = '%s\n'
            else:
                fmt = '%s\n'

            for item in order:
                # Write each variable out separated by self.__rowdelim
                val = vv[item]

                if item == 'dimnames':
                    # Write number of dimensions first
                    outfile.write('%d\n' % len(val))
                    for dd in val:
                        # Write dimension names
                        outfile.write('%s\n' % dd)
                elif item == 'valuetype':
                    # dimsize (which is computed) must be written before valuetype
                    outfile.write('%d\n' % dimsize)
                    outfile.write('%d\n' % val)
                elif item == 'values':
                    # Write one value per line
                    for xx in val.flatten():
                        outfile.write(fmt % xx)
                elif item == 'name':
                    # Write the self.__rowdelim before the variable name
                    outfile.write('%s\n' % self.__rowdelim)
                    outfile.write('%s 10\n' % val)

        outfile.close()

    def write_param_file(self, filename):
        # Write the parameters out to a file

        if not self.__isloaded:
            self.load_file()

        outfile = open(filename, 'w')

        for hh in self.__header:
            # Write out any header stuff
            outfile.write('%s\n' % hh)

        # Dimension section must be written first
        dimparent = self.__paramdict['Dimensions']

        outfile.write('%s Dimensions %s\n' % (self.__catdelim, self.__catdelim))

        for (kk, vv) in iteritems(dimparent):
            # Write the dimension names and values separated by self.__rowdelim
            outfile.write('%s\n' % self.__rowdelim)
            outfile.write('%s\n' % kk)
            outfile.write('%d\n' % vv)

        # Now write out the Parameter category
        paramparent = self.__paramdict['Parameters']
        order = ['name', 'dimnames', 'valuetype', 'values']

        outfile.write('%s Parameters %s\n' % (self.__catdelim, self.__catdelim))

        for vv in paramparent:
            dimsize = vv['values'].size
            valtype = vv['valuetype']

            # Set a format string based on the valtype
            if valtype == 1:
                fmt = '%s\n'
            elif valtype == 2:
                # fmt = '%f\n'
                fmt = '%s\n'
            else:
                fmt = '%s\n'

            for item in order:
                # Write each variable out separated by self.__rowdelim
                val = vv[item]

                if item == 'dimnames':
                    # Write number of dimensions first
                    outfile.write('%d\n' % len(val))
                    for dd in val:
                        # Write dimension names
                        outfile.write('%s\n' % dd)
                elif item == 'valuetype':
                    # dimsize (which is computed) must be written before valuetype
                    outfile.write('%d\n' % dimsize)
                    outfile.write('%d\n' % val)
                elif item == 'values':
                    # Write one value per line
                    for xx in val.flatten(order='A'):
                        outfile.write(fmt % xx)
                elif item == 'name':
                    # Write the self.__rowdelim before the variable name
                    outfile.write('%s\n' % self.__rowdelim)
                    outfile.write('%s\n' % val)

        outfile.close()


# ***** END of class parameters()